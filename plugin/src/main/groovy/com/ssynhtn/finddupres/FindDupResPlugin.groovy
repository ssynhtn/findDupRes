/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package com.ssynhtn.finddupres

import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.tasks.TaskAction

import java.security.MessageDigest

/**
 * scan files in res folder to find duplicates
 */
class FindDupResPlugin implements Plugin<Project> {
    void apply(Project project) {
        // Register a task
        project.task("findDupFile", type:DuplicateFileTask) {
            group = "help"
            description = "find duplicate res files"
        }
    }
}

class DuplicateFileTask extends DefaultTask {
    private boolean abortOnDuplicate;

    public boolean getAbortOnDuplicate() {
        return abortOnDuplicate;
    }

    void setAbortOnDuplicate(boolean abort) {
        this.abortOnDuplicate = abort;
    }

    @TaskAction
    def printFiles() {

        def resDirFiles = gatherResDirs()

        def map = computeFileMD5Rec(resDirFiles)
        def dups = findDuplicates(map)


        if (dups.size() > 0) {
            logger.quiet("quiet warning", new GradleException("aha"))
        } else {
            logger.quiet("no duplicate files found")
        }

        dups.each { key, set ->
            println "dups with key $key"
            set.each {
                println it
            }
            println ""
        }

    }

    List<File> gatherResDirs() {
        List<File> files = new ArrayList<>()
        if (project.pluginManager.hasPlugin("com.android.application") ||
            project.pluginManager.hasPlugin("com.android.library")) {
            def resDirs = project.android.sourceSets.main.res.source
            if (resDirs != null) {
                resDirs.each {
                    files.add(project.file(it))
                }
            }
        }

        return files
    }

    Map<String, Set<File>> findDuplicates(Map<File, String> map) {
        Map<String, Set<File>> dups = new HashMap<>()
        map.each {f, md ->
//            def fs = dups.computeIfAbsent(md, key -> new HashSet<>())
            def fs = dups.get(md)
            if (fs == null) {
                fs = new HashSet<File>()
                dups.put(md, fs)
            }

            fs.add(f)
        }

        return dups.findAll {key, fs ->
            fs.size() > 1
        }
    }

    def computeFileMD5Rec(List<File> files) {
        def res = new HashMap<>()
        if (files != null) {
            files.each {
                res.putAll(computeFileMD5Rec(it))
            }
        }

        return res
    }

    def computeFileMD5Rec(File file) {
        def res = new HashMap<>()
        if (file == null) return res
        if (file.isFile()) {
            def md5 = fileMD5(file)
//            println "${file.getCanonicalPath()}, ${md5}"
            res.put(file, md5)
            return res
        }

        def files = file.listFiles()
        files.each {
            res.putAll(computeFileMD5Rec(it))
        }

        return res
    }

    def fileMD5(File file) {
        if (file == null || !file.isFile()) return ""
        MessageDigest digest = MessageDigest.getInstance("MD5")
        byte[] data = readBytes(file)
        digest.update(data)
        byte[] out = digest.digest()
        return toHex(out)
    }

    def HEX_ARRAY = "0123456789ABCDEF".toCharArray();
    def toHex(byte[] data) {
        char[] hexChars = new char[data.length * 2];
        for (int j = 0; j < data.length; j++) {
            int v = data[j] & 0xFF;
            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
        }
        return new String(hexChars);
    }

    def readBytes(File file) {
        byte[] data = new byte[(int) file.length()]
        def input
        try {
            input = new BufferedInputStream(new FileInputStream(file))
            input.read(data)
            return data
        } finally {
            if (input != null) {
                input.close()
            }
        }

    }
}
